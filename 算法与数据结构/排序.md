# 排序

排序的算法有很多，有些甚至连名字都没听过，比如**猴子排序、睡眠排序、面条排序等**，而最常用的有：**冒泡排序、归并排序、快速排序、计数排序、基数排序、桶排序**

## 如何分析一个“排序算法”

对于算法执行效率的分析，一般从以下几个方面衡量：

1. 最好情况、最坏情况、平均情况时间复杂度
2. 时间复杂度的系数、常数。低阶
3. 比较次数和交换（或移动次数）
4. 排序算法的内存消耗

### 原地排序

原地排序算法，就是特指空间复杂度为O(1)的排序算法

### 排序算法的稳定性

如果待排序的序列中存在值相等的元素，**经过排序后，相等元素之间原有的先后顺序不变**

如果顺序不变，叫做**稳定的排序算法**

如果顺序发生改变，叫做**不稳定的排序算法**

## 订单问题

在一组订单中，我们需要按照金额和时间进行排序，金额从大到小，时间从后往前，那么排序时的计算思路是什么了：

首先，我们先按照时间逆序进行排序，保证时间上的排序没有问题，然后用稳定的排序算法对金额进行排序，这样就完成了我们的需求

## 冒泡排序

思路：冒泡排序要**将相邻的两个数据进行对比，看是否满足大小关系**，如果不满足就进行**互换**，每一次冒泡都会让一个数据到达它需要的位置，重复n次，就完成n个数据的排序工作

可以理解为每一轮找到一个最大值进行后移，直到没有数据需要移动为止

代码优化上，当发现数据没有做移动时就可以终止循环了

```java
public static Integer[] bubbleSort(Integer[] param){
        if(param == null || param.length == 0){
            return null;
        }
        if(param.length == 1){
            return param;
        }

        int x = 0;
        //控制循环次数
        for(int i = 0 ; i < param.length; i++){
            boolean flag = false;
            //控制交换流程
            for(int j = 0; j < param.length-i - 1; j++){
                if(param [j] > param[j+1] ){
                    int temp = param[j+1];
                    param[j+1] = param[j];
                    param[j] = temp;
                    flag = true;
                }
                x++;
            }
            if(!flag){
                break;
            }
        }
        System.out.println("执行循环次数：" + x);
        return param;
    }
```

代码实测上，进行了优化后，代码的循环次数会有减少

### 冒泡算法是原地排序算法吗？

只涉及相邻数据的交换操作，只需要常量级的临时空间，**是一个原地排序算法**

### 冒泡排序是稳定的排序算法吗？

数据操作只对比当前数据小的进行对换，不涉及相同值时的替换，**是稳定的排序算法**

### 那么时间复杂度？

时间复杂度最好的是已经有序，也就是循环一遍即可，也就是O(n)，最坏是顺序完全相反，需要进行全部循环才能得到，时间复杂度为O(n<sup>2</sup>)，平均时间复杂度为O(n<sup>2</sup>)

## 插入排序

思路：对数组从前到后取每一个值，在数组内进行比较，找到比它大的值，插入到这个数据的前面，整体数据进行后移

可以理解为第一个数据不需要比较，第二个数据和第一个比较，第三个数据和前两个比较，第四个数据和前三个数据做比较，以此类推，最终将数据放到需要放置的位置

优化思路，左边可以看成是一个有序的数组，当前值如果比第一个小，那么就直接挪位即可，不需要再进行比较，挪完位可直接跳出循环

```java
public static Integer[] insertSort(Integer [] param){
        if(param == null || param.length == 0){
            return null;
        }
        if(param.length == 1){
            return param;
        }

        //控制循环次数
        for(int i = 1; i < param.length; i++){
            //提取数据
            int a = param[i];


            int j = i-1;
            for(; j>=0; j--){
                if(param[j] > a){
                    param[j+1] = param[j];
                }else {
                    break;
                }
            }
            param[j+1] = a;
        }
        return param;
    }
```

代码实测，进行优化后循环次数有降低

### 插入算法是原地排序算法吗？

使用的是原空间进行，未涉及到新的空间申请，**是一个原地排序算法**

### 插入排序是稳定的排序算法吗？

数据操作只对比当前数据小的进行对换和后移，不涉及相同值时的替换，**是稳定的排序算法**

### 那么时间复杂度？

时间复杂度最好的是已经有序，也就是循环一遍即可，也就是O(n)，最坏是顺序完全相反，需要进行全部循环才能得到，时间复杂度为O(n<sup>2</sup>)，平均时间复杂度为O(n<sup>2</sup>)

## 选择排序

思路：排序从末尾开始寻找，找到数据最小的值，放到左边的有序集合中

```java
public static Integer[] selectSort(Integer [] param){
        if(param == null || param.length == 0){
            return null;
        }
        if(param.length == 1){
            return param;
        }
        int x= 0;

        for(int i = 0; i<param.length; i++){
            int temp = param.length-1;
            for(int j = param.length-1; j > i; j--){
                if(param[j-1] < param[j]){
                    temp = j-1;
                }
            }
            if(temp != i){
                int value = param[i];
                param[i] = param[temp];
                param[temp] = value;
                x++;
            }
        }
        return param;
    }
```

### 选择算法是原地排序算法吗？

使用的是原空间进行，未涉及到新的空间申请，**是一个原地排序算法**

### 插入排序是稳定的排序算法吗？

数据操作是选择最小的数据进行位置互换，但是涉及到了位置变动，所以是**不稳定的排序算法**

### 那么时间复杂度？

时间复杂度最好的是已经有序，也就是循环一遍即可，也就是O(n)，最坏是顺序完全相反，需要进行全部循环才能得到，时间复杂度为O(n<sup>2</sup>)，平均时间复杂度为O(n<sup>2</sup>)

## 冒泡排序和插入排序的区别

冒泡排序不管怎么优化，元素交换的次数是一个固定值。插入排序不管怎么优化，元素移动的次数是一个固定值。但是从代码来看，冒泡排序的数据交换比插入排序的数据移动要负责。一个是整体移动，一个是分次交换，在时间上消耗的更多。

在性能分析上，通过实践分析，插入排序比冒泡排序的时间更短

## 小结

冒泡算法可以说是两个数据间的比较，对于大的进行后移

插入算法是找，找到比它小的数据，进行整体后移

选择算法是找最小的，然后和合适的位置进行互换