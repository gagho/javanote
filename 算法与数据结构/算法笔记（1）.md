# 算法笔记（1）

## 1、时间复杂度

时间复杂度全称是**渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系**

### 几种常见时间复杂度量级（按数量递增）

+ 常量阶 **O(1)**
+ 对数阶 **O(logn)**
+ 线性阶 **O(n)**
+ 线性对数阶 **O(nlogn)**
+ 平方阶 **O(n<sup>2</sup>)** 、立方阶**O(n<sup>3</sup>)**...
+ 指数阶 **O(2<sup>n</sup>)**
+ 阶乘阶 **O(n!)**

对于以上分类，可以粗略的分为两类，**多项式量级**和**非多项式量级**，其中，非多项式量级只有两个：**O(2<sup>n</sup>)和O(n!)**

当数量n规模越来越大时，非多项式量级算法的执行时间会急剧增加，解出时间会无限增长，所以**非多项式时间复杂度的算法其实是非常低效的算法**

时间复杂度更多的是计算代码的的**运行时间**，而其中的O是没有实际意义的

#### O(1):

其实就是代码中并没有包含任何循环、递归等逻辑，所有的代码都**只要执行一次，与n无关,与代码行数无关**，例：

```java
int (int n){
	int i = 1;
	int x = 2;
	int y = 3;
}
```

#### O(n):

属于代码中的循环逻辑，对于代码的遍历进行，循环中执行了n次，**只关注循环执行次数最多的一段代码**，例：

O(n):

```java
int a(int n){
	for(int i = 0; i < n ; i++){
		System.out.println(i);
	}
}
```

#### O(n<sup>2</sup>):

```java
int b(int n){
    int x = 0;
	for(int i = 0; i < n ; i++){
		for(int y = 0; y < n ; y++){
			System.out.println(y);
		}
	}
}
```

#### O(n)中的乘法法则：

在循环中调用另一个方法的循环，可以认为是**循环嵌套**，时间复杂计算可以是认为是n<sup>x</sup>:

```
int a(int n){
	for(int i = 0; i < n ; i++){
		b(n);
	}
}

int b(int n){
    int x = 0;
	for(int i = 0; i < n ; i++){
		for(int y = 0; y < n ; y++){
			System.out.println(y);
		}
	}
}
```

上例的时间复杂度为n<sup>3</sup>

#### O(logn)和O(nlogn):

在循环过程中，对于规律的乘法或者说是对数运算时，时间复杂度为**O(logn)**：

```java
void a(int n){
	int i  = 1;
	while(i < n){
		i = i *2;
	}
}
```

以上代码的时间复杂度为**O(log<sub>2</sub>n)**；在采用大O标记复杂度时，可以忽略系数，即为**O(log<sub>2</sub>n)** = **O(log<sub>3</sub>n)** = **O(logn)**,所以统一表示为**O(logn)**。

**如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了**

#### O(m+n)、O(m*n)：

代码复杂度由两个数据的规模来决定

```java
void a(int m, int n){
	for(int i = 0; i< m; i++){
		System.out.println(i)
	}
	for(int j=0;j<n;j++){
		System.out.println(j)
	}
}
```

以上时间复杂度为**O(m+n)**,如果两个for循环为嵌套，则时间复杂度为**O(m*n)**

## 2、空间复杂度

空间复杂度的全称是**渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系**

```java
void pint(int n){
	int i = 0;
    int [] a = new int [n]
}
```

以上代码的空间复杂度为O(n)，前面定义已知变量都为O(1)，如果变量n造成了空间的变化，则和时间复杂度的计算规则一样

## 3、复杂度分析

```java
int find(int [] array, int n, int x){
    int pos = -1;
	for(int i=0;i<n;i++){
        if(array[i] = x){
            pos = i;
            break;
        }
    }
    return pos;
}
```

对以上代码进行分析，由于代码中有查找到后进行了循环跳出，所以时间复杂度并不能进行一个有效的计算

#### 最好情况复杂度，就是在最理想情况下，执行这段代码的时间复杂度

上述代码中，最理想的就是所需要的查询的在第一位，复杂度为O(1)

#### 最坏情况复杂度，就是在最坏的情况下，执行这段代码的时间复杂度

上述代码中，最坏的情况就是在遍历后任然未找到需要的数据，复杂度为O(n)

#### 平均情况复杂度，就是在最好和最坏之间的平均时间复杂度

