# 网络

## 网络模型

从底向上：

1. 物理层

   电脑之间的联网硬件（猫，路由器，光缆），把各个电脑连接起来的，属于物理层，物理层负责传输0和1的电信号（硬件层）

2. 数据链路层

   架构在物理层之上。对物理层的电信号进行分组和描述以及数据方向处理（协议层）。对每组电信号进行分组。每组有电信号叫做数据包，也叫一帧，分为标头和数据，标头中包含说明性的东西，比如发送者，接收者和数据类型之类的

   以太网协议：会要求必须有接收者的mac地址，发送后会在内网进行广播，内网设备对比自己的mac地址是否匹配，匹配的就是接收者，但是这种广播模式仅仅针对一个子网（局域网）

3. 网络层

   负责点到点传输（主机或路由之间的传输），解决数据包通过结点传输的问题，主要包含的是网络地址和传输地址，也就是IP和mac

4. 传输层

   网络层，是基于ip协议，进行主机和主机间的寻址和通信的，然后传输层，其实是建立某个主机的某个端口，到另外一个主机的某个端口的连接和通信的。

   就是通过socket来实现通信的，通过socket就可以基于tcp/ip协议完成一系列的比如基于ip地址和mac地址转换和寻址啊，通过路由器通信啊之类的，而且会建立一个端口到另外一个端口的连接。

   udp和tcp都是传输层的协议，作用就是在数据包里加入端口号，可以通过端口号进行点对点的通信了。udp协议是不可靠的，发出去人家收到没有就不知道了；tcp协议是可靠的，要求三次握手，而且要求人家接收到数据必须回复你

   传输层的tcp协议，仅仅只是规定了一套基于端口的点对点的通信协议，包括如何建立连接，如何发送和读取消息，但是实际上如果你要基于tcp协议来开发，一般是用socket，java socket网络编程，

5. 应用层

   应用层，我们就假设综合了会话层、表示层和应用层了，3层合成1层。

   最常见的，应用层的协议就是http协议，进行网络通信

   也就是做数据处理

4层协议也就是：数据链路层（以太协议）、网络层（IP协议）、传输层（tcp协议）、应用层（http协议）

7层：物理层（网线、光缆），会话层、表示层、应用层 ->应用层

## 网络通信

### 浏览器请求的过程

1. 浏览器访问域名，DNS服务器解析后获取到IP地址
2. 浏览器锁在电脑会通过IP地址去判断和当前是否是同一个子网，通过子网掩码与IP地址进行与运算进行判断
3. 非子网的情况下回打包数据包通过网关进行转发，通过Http协议进行转发
4. http协议包含请求方法，请求url，http版本做为请求头，请求体中带有参数，将Http请求体打包成一个数据包
5. tcp协议设置端口，发送方端口随机选择，接受方默认请求端口一般是80，将数据包封装到tcp数据包中，加入tcp头，存放了端口信息
6. 网络层走IP协议，将tcp的头和数据包放到ip数据包中，ip头存放本机和目标机器的ip地址
7. ip协议方法ip不在一个子网内，将数据包通过以太网协议发布到网关上去，通过网关转发出去
8. 数据链路层将IP头和IP数据包封装到以太网数据包中，加入以太网数据头，数据头存放了本机网卡的mac地址和网关的mac地址，以太网的书包限制是1500个字节，超出的的话需要将数据包切割，每个数据包中的有以太头，IP和切割后的数据包以及序号
9. 以太数据包通过交换机发到各级网关，最终进入到访问的服务器中去
10. 服务器接收到数据包后，根据序号将数据包凭借，然后拿出tcp数据包，再获取到http数据包，读取内容，内部处理后将结果封装成htp响应报文，再一样的过程返回回去。

## tcp三次握手

ACK、SYN、FIN

第一次握手，客户端发送连接请求报文SYN=1、ACK=0，seq = x也就是客户端的连接请求

第二次握手，服务器收到SYN=1的报文，需要返回一个确认的报文，ack=x+1， SYN=1,ACK=1，seq=y。发送给客户端，处于可连接状态

第三次握手，客户端收到报文，将ack= y+1，ACK = 1, seq = x+1

其实就是来回的三次请求，每次带上tcp的报文查看是否正确，然后根据协议进行连接

## tcp 断开连接的四次挥手

第一次挥手，客户端发送报文进入等待状态

第二次挥手，服务端收到报文进入等待状态

第三次挥手，服务器发送连接释放报文，服务端进入等待断开状态

第四次挥手，客户端接收到连接，发送应答报文，在一定时间后关闭连接资源，服务端接收到报文后关闭连接资源

## http协议工作原理

http请求封装到应用层数据包，封装在tcp数据包，封装在ip数据包，封装在以太网数据包，如果过大，可能会拆成几个包，走以太网协议+交换机 -› 广播 -› 网关 -› 多个网关 -› 目标的机器 -› 一层一层拆包 -› http请求报文 -› 传递给tomcat -› spring mvc -› http响应 -› 一样的路径会去

### 版本区别

http 1.0要指定keep-alive来开启持久连接，默认是短连接

http 1.1默认支持长连接，就是说，浏览器打开一个网页之后，底层的tcp连接就保持着，不会立马断开，之后加载css、js之类的请求，都会基于这个tcp连接来走。http 1.1还支持host头，也就可以支持虚拟主机；而且对断点续传有支持。

ttp 2.0，支持多路复用，基于一个tcp连接并行发送多个请求以及接收响应，解决了http 1.1对同一时间同一个域名的请求有限制的问题。二进制分帧，将传输数据拆分为更小的帧（数据包），frame（数据包，帧），提高了性能，实现低延迟高吞吐。

## Http长连接

Http本身没有长短连接的说法，其实就是tcp的长连接和短连接，http1.1以后默认都是长连接

http1.0，底层tcp是短连接，浏览器发起请求后tcp3次握手建立连接，4次挥手释放连接，每次请求都会先连接再断开

http1.1以后，tcp3次握手，建立连接，无论有多少个请求都走同一个tcp请求，走了n次请求后，tcp释放资源断开连接