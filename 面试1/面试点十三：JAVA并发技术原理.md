# JAVA并发技术原理

主要包括了volatile、Atomic、ThreadLocal、synchronized、读写锁相关

## Java规范

**Java规范规定所有变量写操作都是原子的**

在java语言规范里,int i = 0， flag = true。各种变量的**简单赋值操作，规定是原子的**

**包括引用类型的变量的赋值写操作，也是原子的**

但是很多复杂的操作，i++,  y=y+2这种**先取值计算再赋值的操作**，有**计算操作的，java默认规范是不保证原子性的**，即使是**使用volatile也是不保证原子性的**

### 例外

**32位虚拟机里的long、double类型变量的简单赋值写不是原子性**

因为long和double是64位的。如果多个线程同时并发执行long i = 30；就会导致**有的线程在修改i的时候高32位，有的线程在修改i的低32位**，在转换为10进制的时候，会导致i的值不是30

### volatile

volatile在java中对原子性的保障很有限，在32位的虚拟机中，可以通过**volatile修饰后，可以保障long、double变量的赋值写是原子性的**

## 可见性

### 底层硬件原理

#### 寄存器

处理器都有自己的寄存器，在线程将主内存的变量加载到寄存器里并操作赋值后，其他的处理器在寄存器中还是原来的变量值。就会导致别的寄存器不能看到数据变化

#### 写缓冲器

每个处理器都有一个写缓冲器，线程在对数据操作后写到写缓冲器中，其他的处理器是不能感知到写缓冲器里数据的变化

#### 高速缓存

每个处理器都有自己的高速缓存，处理器可以将数据写到写缓冲器后将数据写到高速缓存或者主内存中，通知到其他处理器数据变化。处理器读数据会优先从高速缓存中读取，会导致读不到主内存里面的数据

#### MESI协议保证可见性

实现：一个处理器将另一个处理器的高速缓存中更新后的数据拿到自己的高速缓存中更新一下来实现同步，这样各个处理器的线程看到的数据就一样了。

处理器在数据写入到写缓冲器后，需要将数据**强制flush到高速缓存或主内存中去**，然后发送消息到总线（bus）去通知其他处理器，其它处理器通过**refresh去高速缓存或者主内存中读取到这个最新的值，更新到自己的高速缓存中去**

在对变量使用了**volatile修饰后，在对数据操作写的时候，就会通过内存屏障，内存屏障会触发flush强制刷新。在对数据读的时候，也会通过内存屏障触发refresh操作强制刷新自己高速缓存的数据**

## 有序性

### 指令重排

1. 代码在编写过程中是按照我们设计的逻辑进行编写
2. 在编译过程中，为了执行效率很有可能会调整代码的执行顺序，尤其是JIT编译器
3. 处理器执行JIT编译好的指令，还是可能会调整顺序
4. 处理器在实际执行指令的时候，硬件层面的组件也可能会导致指令顺序不一样