# Mysql

## 存储引擎

### MyISAM

不支持事务，不支持外键约束，索引文件和数据文件分开，这样在内存里可以缓存更多的索引，对查询的性能会更好，适用于那种**少量的插入，大量查询的场景**（报表系统）

### InnoDB

支持事务，走聚簇索引，强制要求有主键，支持外键约束，高并发、大数据量、高可用等相关成熟的数据库架构，分库分表、读写分离、主备切换，全部都可以基于innodb存储引擎来使用

## 索引

索引是一组数据结构，一般是B+树

B-树：数值大的在右边，数值小的在左边，两个数值之间的数据在左边的子树上，查询的时候通过二分法进行不断的判断轮询查询即可。树里面每个索引节点都有一个data，data中可能是数据，可能是内存地址

B+树：非页子节点不包含data，只有页子节点（底层节点）包含data，子节点中包含了父节点的索引，在最底层的节点上包含有data

### MyISAM

索引文件和数据文件是分开的，也就是data里面存放的是数据的物理地址，在索引文件中搜索到物理地址后进行数据读取

### InnoDB

数据文件本身就是索引文件，也就是key是主键（强制要求主键），根据key创建一个索引，叫聚簇索引，data中存放的就是数据（一条完整的数据），在查询的时候，通过索引就可以直接获取到数据。另外建立的key，也会先去key的索引里去找，叶子节点里的data存放的就是主键，然后再去数据文件里的聚簇索引里去查询到整条数据

如果使用UUID做为索引会导致索引文件占用的资源很大，浪费空间

建议使用自增，这样在创建索引文件时更方便（可能会存在数据安全问题），只需要不断的拼接索引节点就可以了

### 使用规则

联合索引最左前缀匹配原则：条件从左到右，到非索引字段就会终止使用索引

1. 全列匹配：刚好用上了联合索引的所有字段，可以用到索引
2. 最左前缀匹配：搜索条件用到了联合索引的最左边一个或者多个字段，可以用到索引
3. 中间条件非索引：搜索条件没有用到最左前缀匹配，但是用到了间隔字段，可以用到索引，但是有额外过滤工作
4. 没有最左前缀：没用到索引
5. 前缀匹配：模糊查询时%放后面才会使用到索引（后模糊匹配）
6. 范围列匹配：符合最左前缀的能使用索引
7. 包含函数：函数列不使用索引

### 缺点

1. 在插入的时候需要创建索引，所以会对性能会有损耗（尽量创建少的索引）
2. 需要创建索引文件，会占用磁盘
3. 创建索引时尽量选择值几乎不太一样的，索引效果才好

## 事务

### ACID

1. Atomic：原子性，一起成功或者一起失败
2. Consistency：一致性，执行前和执行后的数据一定是准确的
3. Isolation：隔离性，事务不能互相干扰
4. Durability：持久性，事务成功了，永久对数据有效

### 隔离级别

#### 读未提交

A事务修改的数据尚未提交就可以被B事务读取到A的数据，也就是脏读

#### 读已提交（不可重复读）

A事务读取数据，B事务提交了数据，A事务再次读取到的数据就会变成更改后的数据

#### 可重复读

A事务读取数据，B事务提交了数据，A事务再次读取到的数据还是原数据

#### 串行化

幻读：A事务读取全表数据，B事务成功插入了一条数据，事务A查询第二次查询到了B事务的数据，导致两次查的数据不一样

事务A运行期间不运行其他事务运行，解决幻读的问题

### 默认级别

mysql里面**默认的是可重复读**

MySQL是通过MVCC机制来实现的，就是多版本并发控制，multi-version concurrency control。

使用innodb存储引擎，会在每行数据的最后加两个隐藏列，一个保存行的创建时间，一个保存行的删除时间，但是这儿存放的不是时间，而是事务id，事务id是mysql自己维护的自增的，全局唯一。

事务在查询数据时，会查询小于当前事务Id的创建事务Id数据，当有其他事务修改数据时，会新增一条记录数据，并将创建的事务Id设置为新的事务ID，原数据查询时会依据事务id进行查询，查询出来的数据就是原数据。



