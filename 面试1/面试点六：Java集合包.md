# Java集合包

## HashMap

### 底层数据结构

**数组+最简单的原理**

一个固定长度的数组，在设置值的时候对key值进行hash计算，然后对数组长度进行取模，最终结果落在某一个index上，将key值和数据进行存储，在取值时对key值进行再次计算获取值

### jdk1.8中对hash算法和寻址算法的优化

#### hash算法的优化

```java
//JDK1.8以后hashMap里面的一段源码
static final int hash(Object key){
    int h;
    return (key == null)?0:(h==key.hashCode())^(h>>>16);
}
```

**对key进行hashCode运算，然后对key进行了二进制右移16位的异或运算**，将最后计算出来的值转换为32位int值（也就是**将hashCode的高16位和低16位进行异或运算**，避免了hash值后续的冲突，进入的相同的位置）

#### 寻址算法的优化

```java
(n-1) & hash
```

**将key值得hash值与数组长度减一进行与运算**，最终计算出数组中的一个位置

**取模运算的性能比较差一些，为了优化这个寻址过程，(n-1) & hash 的效果和hash对长度取模的效果是一样，而且运算速度会快很多**

（高16位的运算可以基本忽略，**低16位的运算才是重点**）

而在hash算法中，将高16位也参与到了运算，最后**算出来的结果中就包含了高16位和低16位的计算**

### Hash碰撞

**多个key算出来的hash值，与n-1进行与运算后，最后定位出来的位置是一样的**

**解决方案：**

会在这同一个位置上挂一个**链表**，这个链表里放入多个元素，让多个key-value对，放在数组的一个位置中

获取时发现是链表，则遍历链表去找到key-value就行

**链表过长，会导致遍历链表性能变差**

优化：链表长度达到一定长度以后（8），会将链表**转换为红黑树**

### HashMap扩容

由于底层数组，当数组慢了以后，会自动扩容，变成更大的数组

目前扩容是进行**2倍扩容**

#### rehash

数组扩容后需要将原来的数据重新进行hash的与长度减1的与运算，就会让原来的数据重新分配到新数组的不同的位置

