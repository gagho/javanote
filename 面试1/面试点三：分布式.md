# 分布式

## dubbo

### 工作原理

#### 工作分层

1. service层：实现提供者和消费者的接口
2. config层：配置文件
3. proxy层：代理层，代理之间进行网络通信
4. registry层：注册层，提供者进行服务注册供消费者发现
5. cluster层：提供者部署在多台机器上进行集群
6. monitor层：监控层，监控服务调用情况
7. protocol层：负责具体提供者和消费者调用之间的网络通信，封装rpc调用
8. exchange层：信息交换层，封装请求，同步转异步
9. transport层：网络传输层
10. serialize层：数据序列化层

#### 工作流程

1. 服务提供者向注册中心去注册
2. 消费者从注册中心订阅发现服务
3. 消费者调用服务
4. 消费者和服务提供者异步通知监控中心

### 通信协议

1. dubbo协议

   消费者和服务提供者进行单一长连接，NIO异步通信，基于hessian作为序列化协议

   使用场景：传输数据量少（100kb以内），并发量高，消费者数量大于服务提供者

2. rmi协议

   走java二进制序列化协议，多个短连接，适用于消费者和服务提供者数量差不多的情况

3. hessian协议

   走的hessian序列化，短连接

4. http协议

   json序列化

5. webservice

   走SOAP文本序列化

### 序列化协议

基于不同的通信协议，支持多种序列化。但是hessian是默认协议

### 负载均衡策略

1. random loadbalance

   默认策略，随机进行请求分发，可以通过设置服务的权重进行请求量的分配

2. roundrobin loadbalance

   轮询分发，平均发放，可以设置权重进行请求量的分配

3. leastactive loadbalance

   自动感知，对机器性能差的分配的请求越少

4. consistanthash loadbalance

   一致性的hash算法，相同参数的请求分发到一个服务上，服务挂掉时会基于虚拟节点分配到剩余的服务器上去

### 集群容错策略

1. failover cluster策略

   失败时自动切换重试其它机器，是默认的策略

2. failfast cluster策略

   一次失败则立即失败

3. failsafe cluster策略

   出现异常忽略

4. failback cluster策略

   失败了后台记录并定时重发

5. forking cluster策略

   每个都发，只要有一个成功就返回

6. broadcacst cluster

   逐个调用所有的服务机器

### 动态代理策略

默认使用javassist动态字节码生成，创建代理类，可以通过SPI扩展机制配置自己的动态代理策略

### SPI

一个接口多个实现，根据配置在系统中进行不同的实现类调用，jdk实现了SPI机制，但是dubbo也用了spi思想，但是不是用的jdk的，是自己实现的一套

```java
Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
```

Protocol接口，在系统运行时会判断加载那个实例化对象，会自动去找配置的，如果没配置就是使用默认的

### 服务治理

1. 调用链路的自动生成（调用链路图）
2. 服务访问压力以及时长统计
3. 服务分层、调用链路失败监控和报警，服务鉴权，服务可用性监控

### 服务降级

避免服务无法连接时长时间等待，可以通过设置默认返回值或者实现返回，也可以设置超时机制

### 接口幂等性

保证幂等性的三大要点：

+ 唯一标识，对于只执行一次的数据可以进行标识区分
+ 处理完成后对数据进行标记，保证在重复消费时能快速甄别
+ 每次请求进行判断数据是否处理过了（redis标识？）

### 接口顺序性

一般而言是不需要保证顺序性，但是有些特殊情况下需要进行保证，参考MQ的顺序性保证

### RPC架构考虑

+ 注册中心
+ 消费者如何获取服务信息
+ 发起请求（代理）
+ 负载均衡
+ 咋发送请求（nio），数据序列化
+ 服务接收请求（代理）

## zookeeper

### 使用场景

临时节点：服务存在时则存在节点，服务宕机时节点自动删除

1. 分布式协调

   在对接口异步进行完成度的设计，可以在调用方进行节点设置，服务方处理完成后进行节点数据修改，如果执行失败，则可以进行再次消费

2. 分布式锁

   在多个系统进行同时对同一个接口调用时，保证只有一个接口能获取到锁，在接口完成后才会释放zk锁

3. 配置信息管理

   对分布式系统进行统一性配置管理

4. HA高可用

   主备服务器切换，通过节点进行观察服务器状态，在主服务器异常时，则临时节点不存在，备用服务器自动切换成主服务器并注册临时节点，原主服务器重启后，进行节点检测，发现有已存在节点，转为备用服务器

## 分布式锁

### redis分布式锁

官方叫做redlock算法，是redis官方支持的分布式锁算法

#### redis简单实现方式

在redis中设置一个锁值，如果能设置成功，则拿到锁，进行数据处理，处理完成后进行删redis的key，释放锁，如果设置失败，则进行等待，然后一定时间后再尝试获取锁。建议使用lua脚本进行拿锁和释放锁，避免误删锁，如果是直接使用redis进行处理，一定要比较其中的随机值，避免误删

lua脚本如下

```lua
if redis.call('get', KEYS[1]) == ARGV[1] 
    then 
    return redis.call('del', KEYS[1]) 
	else 
    return 0 end
```

缺点：单机情况下如果redis挂了，则锁失效，如果在主从架构下，因为数据同步是异步的，可能会导致锁同步不及时，导致分布式锁失效

#### RedLock

场景假设有多个集群（假设5个），执行以下步骤进行拿锁：

1. 获取当前时间戳（毫秒）
2. 轮流在每个服务器上创建锁，过期时间较短，一般就是几十毫秒
3. 尝试在大多数节点上建立一个锁，大多数的要求是 n/2+1
4. 客户端计算建立好锁的时间，如果立锁时间小于超时时间，就算建立成功
5. 建立失败则依次删除锁
6. 只要别人建立一把分布式锁，你就要不断的去轮询获取锁

### zk锁

#### 简单实现

在节点上尝试创建临时节点，如果创建正常，则获取到锁，如果创建失败，则注册监听器监听这个节点，获取到锁的线程在完成后删除节点，zk在删除节点时会将信息推送给客户端，感知到锁被释放后再次尝试获取锁（而且临时节点可以在进程挂了以后会自动删除，不会形成死锁）

## 分布式session

目前公司采用的是将session存储在redis中

可以考虑使用spring session和redis client进行整合

## 分布式事务方案

### 两阶段提交方案（XA方案）

分成两个阶段

1. 询问，询问每个系统能否正常执行，如果有任意系统不能执行，则事务回滚
2. 执行，在没个系统都返回正常执行，则执行

使用spring + jta即可实现

方案一般适用于跨库操作，但是在微服务中一般都是单库操作，所以使用度不高

### TCC方案

（资金）

try + confirm + cancel

1. try:对各个服务的资源做检测以及资源锁定或预留
2. confirm：实际操作
3. cancel：如果有服务出错，则回滚所有服务

需要写大量的和业务重耦合的代码

适用场景：对系统的一致性要求非常高，常见于资金类型的场景，而且最好各个业务的执行时间都短

### 本地消息表

前一个系统在完成时进行写到一个表中，然后通过MQ进行到B系统中消费，B系统先进行写表，然后进行业务数据的处理，处理完成后B系统通过ZK进行更新A系统。如果失败，则删除B系统中的消息表数据，A系统中定时任务进行重发任务

过于依赖本地的mysql消息表

### 可靠消息最终一致性方案

（库存）

不需要使用本地消息表，直接使用MQ来实现事务

1. A系统发送一个准备消息，如果消息发送失败，则取消操作
2. 消息发送成功，执行本地事务，成功了告诉mq进行确认消息，失败则告诉mq回滚
3. 如果发送了确认消息，则B系统可消费到这条消息
4. 如果在发送确认消息时失败了，MQ则会就消息对A系统进行确认状态（回调接口），在A系统中进行补偿
5. B系统失败的话，可以通过MQ进行重发，或者通过ZK通知到A系统进行重发（保证B系统的幂等性）