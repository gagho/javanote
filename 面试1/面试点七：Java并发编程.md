# Java并发编程

## synchronized

### 底层原理

是和jvm指令和monitor有关系

你如果用到了synchronized关键字，在底层编译后的jvm指令中，会有**monitorenter和monitorexit**两个指令

monitor里面有一个计数器，从0开始的。如果一个线程要获取monitor的锁，就看看他的计数器是不是0，如果是0的话，那么说明没人获取锁，他就可以获取锁了，然后对计数器加1

### 加锁

一个线程第一次synchronized那里，获取到了myObject对象的monitor的锁，计数器加1，然后第二次synchronized那里，会再次获取myObject对象的monitor的锁，这个就是重入加锁了，然后计数器会再次加1，变成2

其他的线程在第一次synchronized那里，会发现说myObject对象的monitor锁的计数器是大于0的，意味着被别人加锁了，然后此时线程就会进入block阻塞状态，什么都干不了，就是等着获取锁

接着如果出了synchronized修饰的代码片段的范围，就会有一个monitorexit的指令，在底层。此时获取锁的线程就会对那个对象的monitor的计数器减1，如果有多次重入加锁就会对应多次减1，直到最后，计数器是0

然后后面block住阻塞的线程，会再次尝试获取锁，但是只有一个线程可以获取到锁

在对象内的方法上加入synchronized修饰符，在方法调用时，会对对象进行加锁，也就是只有一个线程能获取到锁。

在多线程的情况下，就会串行化，会降低代码的执行效率

## CAS（compare and set）

**取值、询问、修改** 

线程操作对象时，先获取到对象的值，然后进行值更改，然后进行设置，在设置时对对象的值和获取的值进行对比，如果一样，证明这期间是没有线程对数据进行更改，则新值设置成功，但是如果值发生了变化，则设置失败，再次进行取值和设置值。

**原子性是在硬件级别保证的**

## ConcurrentHashMap

在多线程中，如果多个线程需要对map进行操作，那么就会出现原子性问题，此时使用synchronized进行加锁，如果对同一位置的put进行加锁，是没有问题的，但是对不同位置的数据进行变更时，加锁则没有必要，java的多线程包则推出了ConcurrentHashMap，它默认实现了线程安全性

### 线程安全的底层原理

+ JDK 1.7之前是多个数组进行分段加锁，每个数组一个锁

+ JDK 1.8后进行锁粒度的优化。一个数组每个元素进行put时加不同的锁，如果两个线程在同一个位置进行put时，采取CAS策略，保证只有一个线程能执行操作

## AQS

**抽象队列式同步器**

### 原理

多线程访问的时候，多个线程基于CAS同时尝试在AQS中进行加锁，这时候会有一个线程加锁成功，其余的加锁失败，加锁成功的线程更新到AQS中，加锁失败的进入AQS的等待队列中，加锁成功的线程在完成后释放锁，这个时候会唤醒等待队列队头的线程，基于CAS进行加锁，这个时候加锁成功继续运行逻辑

这是一个非公平锁，也就是如果在唤醒线程时有一个新的线程进来，则新的线程有可能抢夺到锁，则唤醒的线程需要重新进入队列里进行排队

如果需要做公平锁，则需要在构造函数上传入一个true

```java
ReentrantLock lock = new ReentrantLock(true);
```

此时进来的线程需要先判断等待队列里是否有线程，如果有则进入等待线程，没有则进行锁的占用

## 线程池

系统是不允许无限制的创建线程的，会构建一个线程池，有一定量的线程，让他们执行各种任务，任务执行完成后不销毁自己，等待下一次调用

### 底层工作原理

```java
ExecutorService threadPool = Executors.newFixedThreadPool(3) -› 3: corePoolSize
 
threadPool.submit(new Callable() {
       public void run() {}
});
```

提交任务，先查看线程池的线程数量是否小于corePoolSize，如果小于则创建线程来执行任务，执行完以后线程不会消亡，该线程尝试从一个无界的LinkedBlockingQueue获取新的任务，如果没获取到，则线程阻塞

不断的提交任务，不断的创建线程，直到线程数量达到corePoolSize，这时候则不再新建线程，任务进入到无界的LinkedBlockingQueue，阻塞的空闲线程会直接获取到任务进行处理

### 核心配置参数

+ corePoolSize：核心线程数量
+ maximumPoolSize：最大线程数量
+ keepAliveTime：额外线程无任务最多存活时间
+ new ArrayBlockingQueue‹Runnable›(200)：任务队列

核心线程满了以后，任务会进入任务队列，当队列塞满了就会创建额外的线程去消费任务，数量限制为最大线程数量。如果还是处理不过来，则进行拒绝策略进行拒绝。在任务处理完以后，额外线程阻塞，在keepAliveTime后未接到任务，则线程死亡

### 无界队列的问题（线程池中）

在远程服务异常的情况下，使用无界阻塞队列，会导致队列变得很大，导致内存飙升，还有可能会导致OOM内存溢出

### 拒绝策略（建议）

在有界队列塞满了以后，而且线程池也满了，导致后续任务不能进入队列了，可以考虑自定义一个拒绝策略，建议可以把这个任务信息持久化写入磁盘里去，后台专门启动一个线程，后续等待你的线程池的工作负载降低了，他可以慢慢的从磁盘里读取之前持久化的任务，重新提交到线程池里去执行

如果大量创建线程会导致大量占用内存资源，甚至导致系统崩溃，即便没崩溃也会导致cpu负载过高

