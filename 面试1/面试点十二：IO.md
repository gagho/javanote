## IO

## 进程、线程

### 进程通信方式

管道、命名管道、消息队列、共享内存

1. 管道

   unix系统里，可以创建子进程，共享代码空间，有自己的独立的数据空间，就可以基于管道进行通信（父子进程）

   管道是半双工，也就是只能一端写，另一端读

2. 命名管道

   命名管道解决父子进程限制，相当于一个有名字的文件，名字在文件系统上，数据在内存里，也是半双工的，只能单向滚动

3. 消息队列

   链表结构，进程往链表写，另一个在链表里读

4. 共享内存

   一块物理地址映射到两个内存空间，所以进程之间互相可以共享数据，但是需要锁来进行同步

### 线程切换

时间片算法：cpu给每个线程一个时间片来执行，时间片结束后就保存这个线程的状态，然后切换到下一个线程去执行，多线程并发就是多个线程来回切换，每个线程就一个时间片里执行

## BIO

传统网络通信模型，同步阻塞式IO，在服务端创建一个ServerSocket，客户端的Socket进行连接，服务端创建一个Socket进行通信，然后两端进行阻塞式通信，也就是一定要等服务端处理完成后才能进行下一次请求

### 缺点

每次一个客户端接入就会创建一个Socket，客户端过多时会导致服务端负载过高崩溃

可以做线程池来固定请求数量，但是高并发的时候还是会有延迟

## NIO

基于Reactor模型的同步非阻塞式IO

### Buffer

缓冲区，一般都是将数据写入Buffer中，然后从Buffer中读取数据，有IntBuffer、LongBuffer、CharBuffer等很多种针对基础数据类型的Buffer。

Channel：数据读写

Selector：多路复用器，Selector会不断轮询注册的Channel，如果有Channel上发生了读写事件，selector就会将这些channel获取出来，我们通过SelectionKey获取有读写事件的channel，就可以进行IO操作。一个Selector就通过一个线程，就可以轮询成千上万的channel，这就意味着你的服务端可以接入成千上万的客户端。

核心是非阻塞，一个selector一个线程就可以不停轮询channel，所有客户端请求都不会阻塞，直接就会进来

一个selector线程不断的轮询所有的socket连接，发现有事件了就通知你，然后你就启动一个线程处理一个请求即可，但是这个处理的过程中，你还是要先读取数据，处理，再返回的，这是个同步的过程。

## AIO

基于Proactor模型的异步非阻塞模型。

给操作系统一个buffer，让操作系统自己获取数据去完成写操作，写完以后再回来通知你。