# JVM

## 内存区域

在执行main方法时，tomcat有很多自己的工作线程去执行代码，创建的对象会统一的放在堆内存中，而每个线程会创建独有的栈内存，类都会加载到tomcat的永久代里面

**java8以后的改进**：

之前永久代里面放着一些常量池+类信息，java8以后常量池放到了堆里面，类型信息存放到了metaspace里面（元区域）

## 运行原理

一定有线程去执行代码

类中包含了一个方法，在执行方法时，会自动有一个JVM进程，会默认有一个方法线程，这个线程就负责执行该方法，进而创建各种对象

在tomcat中，类都会加载到JVM中，spring会把类实例化为bean，有工作线程会来执行bean实例里的对象和方法，进而创建其它的各种对象来实现业务逻辑

tomcat启动后，会通过类加载器加载war包中的类，把加载的类信息放到了matespace中去，启动spring容器后，通过反射技术创建bean实例（matespace中的实例信息进行反射），最后把bean实例放在堆内存中，在接收到请求后，会有线程去处理请求，这个时候线程会有独享的内存空间在栈内存中。方法中定义的变量会存放在线程的栈内存中的局部变量表中，局部变量会去引用堆内存中的对象

## 垃圾回收

jvm的内存其实是有限制的，不可能是无限的，内存是昂贵的资源。包括栈内存，matespace都是需要空间的

jvm中有一个内存分代模型，年轻代和老年代

年轻代中分为三个部分，Eden区和两个S区，默认比例是8:1:1，如果Eden区满了，出发垃圾回收，young gc去回收没被引用的垃圾对象

### young GC算法

在代码一边运行一边回收对象是不现实的。所以在垃圾回收时，所有的线程都是停止工作的，然后垃圾回收去判断哪些对象是可以回收的（stop the world）

年轻代，大部分情况下，对象生存周期是很短的，线程执行完方法后创建的对象就变成垃圾，可以进行回收。近乎90%的对象都是垃圾对象

#### 复制算法

将Eden里面存活的对象（有引用的），复制到一块Survive区域，然后将Eden区全部清空

#### 转换到老年代

1. 对象在年轻代熬过了15次young GC
2. young GC的时候S区内存不足
3. 对象特别大且长期存在的情况下

### 老年代垃圾回收算法

因为老年代的对象，很多都是长期存活的对象，并不适用于复制算法。对于老年代而言，垃圾对象并没那么多

#### 标记-整理算法

将老年代里的存活对象标记出来，移动到一起，存活对象压缩到一片内存空间里去，剩余的空间都是垃圾对象给清理掉，剩余的都是连续的可用内存空间，解决了内存碎片的问题

### 常用的垃圾回收器

#### parnew+cms的组合

用parnew垃圾回收器对年轻代回收，多线程进行回收。cms对老年代进行回收

cms:初始标记+并发标记+并发清理（先进行标记和清理，然后进行内存整理）

老年代的垃圾回收算法是很慢的，差不多是年轻代的10倍

#### g1

G1是一个分代的，增量的，并行与并发的标记-复制垃圾回收器。G1还有一个及其重要的特性：软实时（soft real-time）

“软实时”则是指，用户可以指定垃圾回收时间的限时，G1会努力在这个时限内完成垃圾回收，但是G1并不担保每次都能在这个时限内完成垃圾回收。通过设定一个合理的目标，可以让达到90%以上的垃圾回收时间都在这个时限内。





