# 面试点二： 缓存

缓存的作用：高性能、高并发

高性能：查询数据快，返回数据快速

高并发：缓存是走内存的，天然支持大量并发，数据库有连接限制

## Redis

### Redis的线程模型

单线程NIO异步的线程模型

事件处理器：

+ 连接应答处理器

  创建一个socket建立与客户端的连接

+ 命令请求处理器

  处理socket传过来的key和value

+ 命令回复处理器

#### 客户端与redis的一次通信流程

1. 客户端连接到redis的server socket请求建立连接
2. server socket产生一个AE_READABLES事件
3. IO多路复用程序监听所有的socket事件，并将监听到的时间压入队列中
4. 文件事件分派器会从队列中拿到事件，根据事件去找到对应的事件处理器（连接应答处理器）
5. 创建一个新的socket01，与客户端进行连接，并将socket01与命令请求处理器关联起来
6. 发送指令时，会重复以上操作，事件处理器更换成命令请求处理器，还会产生一个AE_WRITABLE事件
7. 根据命令对redis里的数据进行查询和操作
8. redis将事件AE_WRITABLE和命令回复处理器进行关联
9. 返回此次操作的结果
10. redis将事件AE_WRITABLE和命令回复处理器解除关联

#### redis的效率为什么这么高

1. 纯内存操作
2. 核心是基于非阻塞IO的多路复用机制
3. 单线程反而避免了多线程的频繁上下文切换问题

### redis数据类型及场景

+ String

  最基本的类型，普通的set和get，最简单的kv缓存

+ hash

  类似map的结构，缓存对象（非嵌套对象），每次写的时候可以操作里面的某个字段，

+ list

  有序列表，有序且可重复，可以存储一些列表型的数据结构，粉丝列表、评论列表，可以通过lrange命令进行数据个数读取（分页），也可以做简单队列

+ set

  无序集合，自动去重，共同好友类的功能(交集、并集、差集（api）)

+ sorted set(zset)

  排序的set，有一个分数可以进行排序，排行榜功能

### Redis过期策略

1. 定期删除

   redis默认每隔100ms就**随机抽取**设置过期时间的key，如果过期则删除。

2. 惰性删除

   key在调用时检查是否过期，如果过期了，则删除数据

设置过期时间的删除策略为：**定期删除+惰性删除**，如果定期删除漏过了很多key，导致大量的key留存，这个时候使用的是**内存淘汰**机制

1. 内存淘汰机制（LRU）（数据结构里的链表实现）

   根据最新使用的key值进行保留，不经常使用的key值进行删除

实现：借助jdk里面的LinkHashMap进行实现，继承LinkHashMap，构造函数指定大小，覆写删除方法即可

### Redis读写分离

架构：主从架构

一主多从，主负责写，并且将数据同步到其它的slave节点，从节点负责读。所有读的请求全部走从节点

### Redis哨兵模式

哨兵模式是一种特殊的模式，是一个**独立的进程**，原理是哨兵发送命令，等待redis响应，如果主redis没有响应，则证明主redis的服务器下线，这时候会自动切换slave到master，然后通过**发布订阅模式**通知其他服务器，修改配置文件。为了保证哨兵的有效性，可以部署哨兵集群进行监控，这样在哨兵检测主redis下线达到一定数量后，再进行选举master

### redis如何实现高可用

+ redis高并发：主从架构，一主多从，主用来写数据，单机几万的QPS，多重用来查数据，可以提供每秒10W的QPS。还需要容纳大量的数据，那么就要考虑redis集群，而且用redis 集群后，可以提供每秒几十万的读写并发
+ redis的高可用：主从架构加上哨兵模式就可以实现高可用，主宕机的情况下可以快速的切换主

## Redis持久化

redis持久化的意义在于故障恢复，可以在宕机重启后能保留原来的数据

+ RDB

  对redis中的数据进行周期性的持久化

  1. 优点 

     + 会生成多个数据文件，记录每个时间段redis中的数据，比较适合做冷备份

     + 对读写服务的影响小，可以让redis保持高性能（定时）

     + 基于RDB的重启和回复redis进程要更快

  2. 缺点：

     + 丢失率比AOF高，毕竟周期性的不稳定

     + 保存数据过大，会导致服务端提供服务暂停

+ AOF

  对于每条写入数据放入日志文件中，redis重启时可以通过回放AOF指令来重构整个数据集

  1. 优点：
     + 数据保护的更好，也更完整
     + AOF文件过大，进行重写操作时不会影响读写
     + AOF日志文件的命令通过非常可读的方式进行记录，非常适合灾难性误删除操作
  2. 缺点：
     + 同一份数据AOF的日志文件比RDB的备份文件要大
     + 写QPS会比RDB低，因为还要写日志文件
     + 出现过历史bug，恢复时未恢复完全，比RDB要脆弱

如果仅仅作为缓存使用，可以禁止所有的持久化机制

同时使用两个机制时，在redis重启时，会使用AOF来进行数据加载，AOF的数据更为完整

建议使用两种持久化机制

## redis cluster 分布式数据存储的核心算法

缓存热点：数据大量涌入同一个master，造成master热点问题，容易达到瓶颈

1. 自动将数据进行分片，每个master上放一部分数据
2. 提供内置的高可用支持

在redis cluster架构下，每个redis有两个端口（6397，16397）

16397端口用于**节点通信**，用来进行故障检测、配置更新、故障转移授权等

### 最老的hash算法

对于key值进行取模，取模结果一定是在0到节点数量之间，然后将数据存到对应的master上去。问题在于master宕机，就会导致数据失效，会造成数据库被压垮。且因为取模的计算问题，就会导致大部分请求无法获取到有效缓存（取模值的位置发生了变化）

### 一致性hash算法

取key值的hash值，然后会用hash值和每个节点去对比，最终确定数据落在距离自己最近的那个master上（圆环）。在服务器宕机时，在寻找节点时会去寻找下一个节点，其中只会有宕机的那个服务器的数据会进入数据库查询。会有缓存热点的问题，可以采用虚拟节点进行负载均衡。将节点创建多个虚拟节点，分布在环上的不同位置，这样就会让数据进入不同的节点

### hash slot算法：

redis cluster有固定的16384个hash slot，对每个key计算CRC16值，然后在进行取模，可以获取key对应的slot，每个master都会持有部分hash slot。hash slot的移除和增加也很简单，移除会将hash slot移到别的master上，新增时会将slot移动部分到新的master上，客户端可以根据api让指定的数据到同一个hash slot，通过hash tag实现。因为取模是针对于hash slot，所以服务器宕机时并不影响寻址

## redis cluster内部通信机制

### 基础通信原理

维护集群元数据（节点信息、故障等等）一种是集中式，一种是gossip

集中式：元数据的更新和读取时效性好，**数据变更更新及时**，但是元数据集中存储会导致**存储压力**

gossip：元数据分散，更新陆陆续续，有**一定的延时**，**降低了压力**

1. redis节点采取gossip协议进行通信

   互相之间**不断通信**，保持整个集群所有节点的数据是完整的

2. 10000端口

   每个节点都有一个专门用于通信的端口，端口号为使用端口号+10000，每个节点每过一段时间向其余节点发送ping消息，同时返回pong

3. 交换信息

   故障信息，节点的增加和移除，hsah slot信息

### gossip协议

包含多种信息，包括meet、ping、pong、fail

meet：增加新节点加入集群中

ping：交换元数据

pong：返回meet和ping，包含自己的状态和信息，也可用于信息广播和更新

fail：服务器宕机及下线

## jedis内部实现原理

### 基于重定向客户端

+ 请求重定向

  客户端会随机向一个服务器发送key，redis实例接收到后计算key的hash slot，如果是本地就返回，否则就返回moved给客户端，让客户端重定向

  cluster keyslot mykey可以查看key对应的hash slot

+ 计算hash slot

  通过key值的CRC16的值，然后对16384进行取模，拿到hash slot。hash tag可以手动指定key对应的slot，同一个hash tag对应的key，会在同一个hash slot中

+ hash slot查找

  通过gossip协议进行数据交换，就知道每个hash slot在哪个节点上

### 什么是smart jedis

基于重定向客户端，很消耗网络IO，因为大部分情况下都会出现一次重定向，所以本地维护一份hash slot -> node的映射表、缓存，大部分情况下可以走本地缓存就能找到hash slot -> slot，不需要节点通过moved进行重定向，在返回moved时会进行更新映射表，如果5次未找到，则报错

新版本对过度的hash slot更新和ping进行了优化

## 缓存问题应对

### 什么是缓存雪崩

数据查询时首次会查询数据库，后续会查询到缓存中。因为特殊情况下导致缓存不可用，大量请求直接查询数据库，数据库不能承受到大量的请求导致数据库崩溃

### 缓存雪崩的解决方案

+ 事前：保证缓存的高可用（主从、集群）
+ 事中：做多级缓存，本地缓存，进行限流和降级，避免数据库崩溃
+ 事后：做好redis的持久化，快速恢复数据

### 缓存穿透

缓存穿透是意味着外部在查询一个数据可缓存中都不存在的数据，导致数据无法更新到缓存中，请求每次都直接落到数据库上

缓存穿透主要来源是黑客攻击，解决方案可以采用参数校验（参数范围值），对未查询到的数据设置缓存value为null（注意时间限制，避免影响正常业务）

## 缓存与数据库一致性问题

最经典的缓存+数据库读写模式：cache aside pattern

### cache aside pattern

+ 读取的时候先查询缓存，如果缓存没有则查询数据库然后再更新缓存
+ 写的时候，先删除缓存，然后数据入库
+ 删除缓存是为了更好的更新缓存，缓存可能会查询多个地方来进行缓存，而且避免大量的计算缓存（懒加载）

### 处理办法

#### 最初级

问题：先修改数据库，再删除缓存，在删除缓存失败时会导致数据不一致

解决思路：先删除缓存，再修改数据库

#### 比较复杂（高并发）

问题：先删除缓存，但是在还没更新数据库时，有请求数据，查询到老数据放入缓存中，导致两边数据不一致

解决思路：可以考虑使用内部队列进行数据更新和读取，使用id做key可以保证进入同一队列，保证在更新后拿到的都是新数据，就可以保证数据的一致性

优化：可以在更改时进行数据缓存标识，取数据是先判断缓存标识，如果有缓存标识，则读取数据线程进行休眠，然后再进行查询，需要部署多个服务，不然会导致线程大量阻塞（写过多）。需要根据实际业务情况来进行调整

多服务实例部署的请求路由

服务部署多个实例，那么必须保证执行数据更新操作以及执行缓存更新请求，都通过nginx到同一服务实例上

热点路由问题

## redis并发竞争问题

多客户端写redis导致的顺序错乱

使用分布式锁保证每次只有一个客户端进行写入，然后利用时间戳进行比较，用新的数据覆盖旧的数据

